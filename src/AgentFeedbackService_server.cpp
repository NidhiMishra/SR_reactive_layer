// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.
#ifndef AGENTFEEDBACK
#define AGENTFEEDBACK
#include "AgentFeedbackService.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include "reactiveLayer.h"
//#include "SpeechRecognitionService.h"
//#include "SpeechRecognitionService_server.cpp"
//#include "ProtectedClient.h"

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

using namespace  ::imi;
using namespace ::BB;

class AgentFeedbackServiceHandler : virtual public AgentFeedbackServiceIf {
 public:
	 reactiveLayer *Decision;
	 //ProtectedClient<imi::SpeechRecognitionServiceClient> *chatBot;
  AgentFeedbackServiceHandler(/*reactiveLayer *aDecision*/) 
  {
	  //Decision=aDecision;
    // Your initialization goes here
	 // chatBot=new ProtectedClient<imi::SpeechRecognitionServiceClient>("localhost",12010);
  }

  void speakBegin(const std::string& agentName, const  ::imi::Microseconds timestamp)
  {
	  perceptualInput input;
	  input.sensorId="Feedback";
	  input.behaviorType="Start";
	  //chatBot->getClient()->sentenceRecognized("ReactiveLayer",0,"A",0);
	  //Decision->sendInfoBot(0);
	  Decision->updateActivationLevels(input);

    // Your implementation goes here
    printf("speakBegin\n");
  }

  void speakEnd(const std::string& agentName, const  ::imi::Microseconds timestamp)
  {
	  perceptualInput input;
	  input.sensorId="Feedback";
	  input.behaviorType="End";
	  //Decision->sendInfoBot(1);
	 // chatBot->getClient()->sentenceRecognized("ReactiveLayer",0,"B",0);
	  Decision->updateActivationLevels(input);
    printf("speakEnd\n");
  }

  void addDecision(reactiveLayer *aDecision)
  {
	  Decision=aDecision;
  }

};


#endif