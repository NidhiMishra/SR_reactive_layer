// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "SoundService.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include "reactiveLayer.h"
#include "Behavior.h"
#include <iostream>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

using namespace  ::imi;
using namespace ::BB;

class SoundServiceHandler : virtual public SoundServiceIf {
 public:
	 reactiveLayer *Decision;
  SoundServiceHandler(reactiveLayer *aDecision)
  {
    Decision=aDecision;
  }

  void sound(const std::string& sensorID, const  ::imi::Microseconds timestamp, const AudioLocalization& source)
  {
	  if (sensorID == "KinectV2")
		  kinect(sensorID, timestamp, source);
	  else
		  micorphoneArray(sensorID, timestamp, source);
  }

	  void kinect(const std::string& sensorID, const  ::imi::Microseconds timestamp, const AudioLocalization& source)
	  {
		  AudioLocalization correctedSource = source;
		  perceptualInput input;
		  imi::Vec3 pos;
		  float xsd, ysd, zsd, xw, yw, zw, xr, yr, zr;

		  correctedSource.azimuth = source.azimuth;// *180 / 3.14159265;  

		  input.sensorId = "SoundKinectV2";
		  input.source = correctedSource;
		  input.behaviorType = "none";

		  if (input.source.soundtype == imi::SoundClass::PEN) //Group pen and tapping nail as one single category
			  input.source.soundtype = imi::SoundClass::NAILS;

		  input.source.soundtype = imi::SoundClass::SPEECH;

		  if (source.confidence == 1)
			  Decision->updateActivationLevels(input);

	  }


	void micorphoneArray(const std::string& sensorID, const  ::imi::Microseconds timestamp, const AudioLocalization& source)
	{
		// Your implementation goes here
		//imi::SoundClass::IMPULSIVE_SOUND
		AudioLocalization correctedSource = source;
		perceptualInput input;
		imi::Vec3 pos;
		float xsd, ysd, zsd, xw, yw, zw, xr, yr, zr;

		correctedSource.azimuth = 3.14159265 - source.azimuth;

		xsd = 0;
		ysd = 1.6;
		zsd = 1.1;

		//Compute the position of the sound in the sound system
		pos.y = 2.5;
		pos.z = 0.6;
		pos.x = pos.y / tan(correctedSource.azimuth);

		//Convert the position to world coordinate		  
		input.pos.x = pos.y + xsd;
		input.pos.y = -pos.x + ysd;
		input.pos.z = pos.z + zsd;

		input.sensorId = "Sound";
		input.source = correctedSource;
		input.behaviorType = "none";

		if (input.source.soundtype == imi::SoundClass::PEN) //Group pen and tapping nail as one single category
			input.source.soundtype = imi::SoundClass::NAILS;

		Decision->updateActivationLevels(input);

	}

};

/*int main(int argc, char **argv) {
  int port = 9090;
  shared_ptr<SoundServiceHandler> handler(new SoundServiceHandler());
  shared_ptr<TProcessor> processor(new SoundServiceProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;
}*/

